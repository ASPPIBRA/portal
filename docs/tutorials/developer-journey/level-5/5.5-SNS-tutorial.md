# 5.5 Creating an SNS

## Overview

A Service Nervous System (SNS) is an advanced form of DAO. If you recall, we covered DAOs and the NNS in a previous module, [4.4 NNS and governance](../level-4/4.4-nns-governance.md). To recap, a DAO, or decentralized autonomous organization, is a form of decentralized governance that is controlled by the DAO's stakeholders without a central form of authority. The Internet Computer is managed by a DAO known as the Network Nervous System. 

The underlying architecture of an SNS closely resembles the architecture of the NNS, but instead of being used to control the IC, an SNS is used to control a specific decentralized application that is running on the IC mainnet. Any dapp running on the mainnet can be handed over to an SNS, which results in the dapp being owned and controlled by a community. When an SNS takes control of a dapp, the dapp is then managed in the same way that the Internet Computer is managed by the NNS. When an SNS is launched, the ledger defines a unique token for the SNS that is then used by the community for participation in the SNS's community. 

The dapp's community can participate in the dapp's SNS through staking the SNS's native token in a neuron. Then, changes to the dapp are proposed to the community via an SNS proposal. Voting rights work the same way that voting on the SNS does; anyone can stake the SNS's native token into a neuron, and the neuron's voting power is proportional to the quantity of SNS tokens staked within the neuron, the length of their dissolve delay, and the amount of time since the neuron was created.

## How an SNS works

While the core architecture of an SNS resembles that of the NNS, the NNS contains additional canisters that provide important functionalities on the IC, such as the cycles minting canister that is responsible for creating cycles and the registry canister that contains the network's topology. In contrast, an SNS contains a few canisters that do not exist on the NNS, with the most notable canister being the decentralized swap canister used during the launch of an SNS. 

SNSs are provided as a system functionality. For an SNS to be launched, the NNS community must vote on and approve the SNS's original canister code. Once the SNS is launched, the code for the SNS's canisters is maintained by the IC and is changed through SNS proposals that are voted on by the community. All approved SNS canister versions are stored on an NNS canister known as the SNS Wasm Modules canister (SNS-W). Recall that all canisters are compiled into Wasm to be deployed on the IC.

When an SNS is created, the SNS-W canister is responsible for deploying the latest version of the SNS's canisters. When an SNS is updated, an NNS proposal is used to add a new version of the SNS's canisters to the SNS-W canister. Then the SNS's community decides, via SNS proposal, if they'd like to adopt the new, approved version into the SNS. Once approved via proposal, the updates are applied to the SNS. 

All SNSs are hosted on the SNS subnet, which is exclusively used to host SNSs. This allows for simplified verification for end users, since end users can simply verify that an SNS is running on the SNS subnet, and therefore trust that the SNS's underlying code has been approved by the NNS community. 

An SNS is comprised of the following canisters:

- **SNS governance canister**: The governance canister defines who can participate in the SNS's governance decisions and automatically triggers the execution of all decisions. This canister stores the SNS proposals and a record of the neurons that define who the governance participants are. When a proposal is adopted, the governance system automatically triggers the execution of the proposal by calling a defined method. In most instances, the decision of the proposal is executed fully on-chain. 

- **SNS ledger and archive canisters**: The ledger canister implements the ICRC-1 token standard to create a unique token for each SNS. This canister stores the SNS's ledger, which keeps track of how many accounts own SNS tokens, the amount owned by each account, and the history of transactions for the SNS's token. Since the canister has limited memory, to keep the ledger's full history, the ledger canister spawns archive canisters to store the ledger's block history. 

- **SNS index canister**: The index canister keeps a record of which transactions are relevant for a given account. This provides the ability for wallets and other frontends to show all transactions for an accounts without requiring every frontend to implement this functionality themselves.

- **SNS root canister**: The root canister is responsible for upgrading the other SNS canisters and the dapp canisters that the SNS is responsible for governing. 

- **SNS decentralization swap canister**: The decentralization swap canisters, also called the swap canister, is the primary canister involved when an SNS is launched. In a decentralization swap, users provide ICP tokens that are swapped for the SNS's native token. For an SNS to be launched, the decentralization swap must collect a certain amount of initial funding. This canister collects that initial funding and facilitates the distribution of neurons (and therefore the voting power) to the participants of the decentralization swap, making the SNS's governance decentralized. 

### Decentralization swaps

In order for an SNS to be launched, the SNS must have a successful decentralization swap. A decentralization swap is the action of initially funding the SNS by swapping ICP tokens for the SNS's native token. The decentralization swap is done through the SNS decentralization swap canister which is owned and operated by the IC. It is controlled by the NNS root canister. 

When the swap starts, there is a pre-defined amount of SNS tokens to be distributed publicly. During the swap, participants can send ICP tokens to the swap canister to contribute to the SNS's initial funding.

When the swap ends, the collected ICP tokens are swapped for the SNS's tokens. Participants that sent ICP tokens to the swap canister receive SNS tokens in the form of SNS neurons. The amount they receive is pro-rated by the amount of ICP tokens they contributed to the overall amount of ICP collected in the swap. For example, if the swap canister initially held 1000 SNS tokens, and 500 ICP tokens were collected during the swap, the exchange rate would be 2:1, meaning each participant would receive 2 tokens for each ICP token they contributed.

The SNS places the collected ICP into an SNS controlled treasury. After a successful swap, the SNS tokens are owned by the community and the SNS is governed by that community. 

### SNS tokenomics and rewards

Tokenomics refers to the economics of a token system. Tokenizing a DAO can help to introduce new incentives for users to participate in the DAO, since anyone in the world can purchase tokens, contribute to the initial funding of the DAO, or participate in the DAO's decision making. Tokens can be given as rewards to new or active users, helping to attract additional users.

Tokenomics includes a wide range of topics such as:

- Developing the token supply and demand, including minting new tokens or burning existing tokens. Token supply is defined as the amount of token holders willing to sell at a given price. Demand is defined as the amount of tokens that buyers are willing to purchase at a given price. You can learn more about token supply and demand [here](/docs/current/developer-docs/integrations/sns/tokenomics/tokenomics-intro#supply-and-demand).

- Determining how tokens are used. Token utility can be used for several different use-cases, such as governance within the SNS, currency within the dapp, operations, decentralized financial (DeFi) functions, or social finance (SoFi) functions. You can learn more about token use-cases [here](/docs/current/developer-docs/integrations/sns/tokenomics/tokenomics-intro#token-use-cases).

- Allocating the tokens to the participants of the DAO. When considering the initial token allocation for an SNS, you should define which groups or accounts receive how many tokens. Some examples of groups that should be considered to receive tokens are:
    - The DAO treasury: The treasury of the DAO holds tokens that are at the disposition of the DAO. These tokens can be used according to a set of predefined rules set by the DAO. 
    - The pool of tokens for the decentralization swap: The decentralized swap is the pool of tokens distributed to the community via an initial or subsequent decentralization swap. 
    - The seed funders who have invested in the project prior to launch: Tokens should be distributed to anyone who provided initial funding or investment into the project prior to the launch of the DAO. 
    - The development team: Tokens should be distributed to the development team who contributed to the initial version of the DAO.

    You can learn more about initial token allocation [here](/docs/current/developer-docs/integrations/sns/tokenomics/tokenomics-intro#initial-token-allocation).

- Determining incentive mechanisms. One incentive mechanism is rewards for voting on the SNS's proposals. Voting rewards use the same structure as NNS voting rewards. You can read more about voting rewards [here](/docs/current/developer-docs/integrations/sns/tokenomics/rewards).


## Planning an SNS launch

Before diving into the technical details of creating an SNS, it's important to spend time defining the goals of the SNS and the dapp that it controls. When creating an SNS, custom unique settings can be defined for the SNS's tokenomics and governance to match the goals you have defined, so you can define these goals as simple or as complex as desired. 

An SNS's deployment and decentralization swap must be approved by the NNS through a proposal. This proposal is designed to pitch the dapp to the NNS community and potential contributors to the decentralization swap. The proposal should also establish trust within the NNS community that the dapp is sustainable, ready to be governed by a decentralized entity, and has a viable roadmap. For these reasons, it is imperative to consider and present the following within the proposal submitted to the NNS:

- Management team's background and previous application launch success.

- The dapp's technology stack.

- Clear roadmap: Display a clear roadmap that reflect's the goals of the dapp for continued growth and innovation once launched. 

- The dapp's addressable market within the dapp market space.

- Market fit of the dapp: Demonstrate how your dapp fits the market by using growth and usage metrics. It is important to demonstrate that the dapp has active, loyal users.

- Budget and financial details: Provide information regarding the dapp's necessary funding, if applicable, and how the funds raised will be spent. 

- Utility of the token and tokenomics: Explain future utility such as the ability to use the token for in-app purchases, access to additional functions or services within the dapp, and the dapp's interoperability with others applications.

- Information regarding the designed token-holding audience: Provide information regarding the desired holding audience to ensure long-term success and continued development of the initial vision of the dapp's roadmap and intentions. 

- Positive unit economics: Display the ability to generate value per new user that is greater than the cost of acquiring a new user. 

- Business risks and mitigation plans: Provide plans for managing risks such as user adoption, market decrease, or other accesses business risks. 

- Regulatory approvals: Provide a plan for acquiring any necessary regulatory approvals. 

- Growth and competition: Demonstrate how the dapp plans to achieve growth and overcome hurdles related to competition, both present and future.

Additionally, it is important to take into consideration that since tokenizing the dapp and placing it under control of the SNS will decentralized the control of the dapp, resulting in the development of the dapp to slow down. This is due to the process of proposing changes to the dapp via SNS proposals, requiring many people and parties to agree on the changes rather than just the dapp's developers. Therefore, it is recommended that developers of the dapp feel comfortable that code is in a stable position and that the dapp's roadmap reflects a decrease in development speed prior to handing the dapp over to the SNS.

Developers should plan to continue leading the project after the launch of the SNS. This is because despite having decentralized the dapp, it is important that the original developers manage the SNS community as the project matures into its decentralization. In this stage, developers may work closely with the token holders to drive project success and direction. Developers may need to provide data regarding ecosystem growth, the project's financial changes, and take token holder input and feedback to alter the dapp's roadmap. 

## Stages of an SNS launch

- #### Step 1: Choose the initial parameters of the SNS for the dapp.
- #### Step 2: Add the NNS root as co-controller of the dapp.
- #### Step 3: Submit the NNS proposal to create the SNS. 
- #### Step 4: Await the proposal's decision. 
- #### Step 5: If the proposal is approved, the SWS-W canister deploys the SNS canisters. 
- #### Step 6: The SNS-W sets the SNS root as the sole controller of the dapp. 
- #### Step 7: The SNS-W initializes the SNS canisters according to the initial parameters defined in step 1. 
- #### Step 8: The SNS decentralized swap begins. 
- #### Step 9: The SNS decentralized swap ends. 
- #### Step 10: The SNS decentralized swap finalizes. 

Detailed descriptions of each step can be found in the SNS documentation [here](/docs/current/developer-docs/integrations/sns/launching/launch-summary-1proposal). This tutorial will walk through these steps below. 

### SNS launch checklist

Before launching an SNS, the following checklist can be used to assure that your SNS is ready for launch:

- [x] Documentation :
    - [x] Tokenomics specification:
            - [x] Token utility: Define concise use-cases for the DAO's token.
            - [x] Initial token allocation amounts, including which groups or accounts receive how many tokens.  
            - [x] Voting power: Provide information about how voting power will be distributed at the SNS's genesis.
            - [x] Funding target: Maximum and minimum targets needed for the decentralized swap, including information about planned usage of raised funds. 
            - [x] Use the [SNS tokenomics tool](https://docs.google.com/spreadsheets/u/0/d/1eSxkJl94jPt63CdOXH6ROy-WSkacW6P4qcAKMLrfBPc/edit) to analyze and document the SNS's proposed tokenomics. 
    - [x] Technical architecture:
            - [x] Technical architecture overview to describe how the dapp operates. 
            - [x] Whitepaper: This paper should provide information on the dapp's architecture, the goal of launching the SNS, tokenomics, and other information relevant to the community. For inspiration, you can read the Hot or Not whitepaper [here](https://hotornot.notion.site/hotornot/Hot-or-Not-Whitepaper-c539179e51f44867979f4372e4635f59).
            - [x] Project roadmap: Showcase the plan for the dapp, including past the SNS launch. This should display the vision for the dapp created by the dapp's teams and developers.
    - [x] Disclosure of dependencies: Disclose what possible off-chain services or 3rd party service providers the dapp may rely on.
    - [x] Create an SNS configuration file: Create the SNS's initial configuration file that will be submitted to the NNS for approval. This is a `.yamp` configuration file that defines the token name, supply, distribution, transaction fees, dissolve delays, and more. A template for this file can be found [here](https://github.com/dfinity/ic/blob/master/rs/sns/cli/sns_init_template.yaml). 
    - [x] Create an NNS proposal: Before an SNS can be launched, the NNS must approve of the SNS via a proposal. 
- [x] Technical prep and testing:
    - [x] Security review: Conduct a security review that includes fixing any risky findings. 
    - [x] Open sourcing: If your dapp is not already open source, it should be open sourced prior to the SNS launch. A dapp is not truly decentralized if the source code is not shared with the community, and it is hard for community members to make a proper voting decision regarding dapp upgrades without having full visibility into the code. 
    - [x] Create a reproducible build: From the open source code, a reproducible build should be created. You can read more about reproducible builds [here](/docs/current/developer-docs/backend/reproducible-builds). 
    - [x] Test dapp operations with an SNS testflight: Before requesting an official SNS production launch, it is highly encouraged to test their deployed dapp's operations via SNS proposals using the SNS testflight suite. 
    - [x] Integrate an SNS frontend into the dapp: Decide whether the SNS's functionality will be integrated into the frontend of the dapp or not. One example of integration into the frontend is to include the SNS proposal voting on the dapp's frontend. 
    - [x] Test the SNS launch locally.
- [x] Community consultation:
    - [x] Publish the tokenomics, whitepaper, roadmap, and technical architecture documents.
    - [x] Execute a community discussion on the Internet Computer forum to discuss the dapp's decentralization plans.
- [x] SNS launch workflow:
    - [x] Hand over control of the dapp to the NNS through an NNS proposal. 
    - [x] Submit the SNS decentralization proposal. 
    - [x] Setup custom SNS functions to execute code on SNS managed canisters via SNS proposals. More information can be found in the documentation on how to [manage an SNS](/docs/current/developer-docs/integrations/sns/managing/making-proposals). 



## Creating a sample SNS

To create an SNS, first you will need a dapp that you'd like to be governed by the SNS. Remember that the SNS is the governance for the dapp, not the dapp itself. For this tutorial, you can follow along using any dapp that you've created yourself or through one of the previous tutorials in this series. This tutorial will showcase how to create an SNS using the poll dapp that you created in module [1.3: Creating your first dapp](../level-1/1.3-first-dapp.md), since this is a simple dapp that includes a frontend canister. 

You can clone the code for that dapp from the repo [here](https://github.com/jessiemongeon1/dev-journey-poll-dapp/tree/main).

### Prerequisites

Before you start, verify that you have set up your developer environment according to the instructions in [0.3 Developer environment setup](../level-0/03-dev-env.md).

### Integrating an SNS with the ledger canister

Recall that the SNS ledger canister keeps tracks of the account balances for a token and the transactions between accounts on-chain. The ledger canister uses the ICRC-1 standard. To deploy an ICRC-1 ledger, refer to the previous module [4.2: ICRC-1 tokens](../level-4/4.2-icrc-tokens.md) where you deployed an ICRC-1 ledger locally, then created an ICRC-1 token.

### Integrating an SNS with the index canister

Recall that the SNS index canister is used to fetch transactions from the ledger canister and index them by account, providing the ability for transactions to be queried by account. The index canister queries transactions from the ledger canister at each heartbeat to build the index of each known transaction for each account. 

When the NNS creates a new SNS, it will deploy the SNS's index canister as part of the deployment process. To deploy the index canister locally, follow the instructions found [here](/docs/current/developer-docs/integrations/icrc-1/icrc1-index-setup). 

As part of the deployment of the index canister, you will need the principal of the ICRC-1 ledger canister that the index canister should be indexing. To configure this, you can deploy the index canister with the command:

```
dfx deploy icrc1-index --argument "(record {
      ledger_id = principal \"rrkah-fqaaa-aaaaa-aaaaq-cai\"
    }
)"
```

### SNS asset canisters

There are different reasons why you might want to interface with an SNS project. For example, you might want to integrate some of the SNS DAO functionality in the frontend of your dapp canister such that the dapp users can also vote on relevant SNS proposals (that govern and change the dapp) directly in the same application. However, you might also consider interfacing with SNSs if you work on a project that builds a wallet dapp or DEX, for example to provide an interface to the SNS swap, the SNS governance, or the SNS ledger.

sns-js library
For interfacing with an SNS project, you can use the sns-js library.

sns-js can be utilized with two distinct approaches. The first approach is explorative, where you only need to provide the SNS root canister ID of your SNS project to initialize a wrapper that handles routing the calls to the appropriate canister. This means having a single entry point for all functions. The second approach, which is more common, involves instantiating the specific canisters you require.

Please refer to the following links to learn how to integrate with:

SNS governance
SNS root
SNS swap
SNS wrapper which knows all SNSs and can therefore serve as a nice way to access different SNSs' data.

The asset canister provides users with a way to store and retrieve static assets from a canister deployed on the IC. Generally, asset canisters are used to serve HTML, CSS, or JavaScript assets, which are typically part of a dapp's frontend. For this reason, the asset canister is also referred to as the frontend canister. For purposes of this guide, it will be referred to as the asset canister.

In the context of the SNS, a dapp's associated asset canister serves the frontend assets related to the dapp and may also include a frontend to the SNS DAO, e.g., through which users can vote on governance proposals.

The contents of the asset canister must be configured prior to the launch of the SNS, and any changes afterwards must be made by a principal with the Prepare permission. Principals with this Prepare permission can make a batch of changes to the asset canister and then 'lock' those changes. To have those changes applied, a proposal must be submitted. Anyone can submit the proposal for the 'locked' changes. Once changes are proposed, they can be voted on by the SNS DAO. If approved, the SNS governance canister is the only one that can commit the approved changes. This configuration assures that changes to the asset canister are only made by approved proposals. These changes are referred to as 'updates' to the asset canister in the remainder of this document.

This section is relevant if your project contains an asset canister and describes how you can test handing over control of an asset canister to an SNS.

In this document, the term upgrade refers to deploying an upgraded version of a canister's WebAssembly module.

The term update refers to changing or updating the assets stored within an asset canister.

Deploying an asset canister
An asset canister must first be deployed before control of it can be handed over to an SNS. When a dapp's control is handed over to an SNS, this is also true for the associated asset canister.

The general overview of deploying an asset canister during an SNS launch is as follows:

First, the asset canister must be created with or upgraded to a Wasm file from dfx 0.14.1+.
Then, the dapp should hand control of the asset canister over to the SNS by setting the following permissions:
The SNS governance canister is given Commit permissions. This is done by the previous developer using the grant_permissions command (see the granting permissions section below), otherwise the SNS must grant this permission once it is a controller.
A whitelist of principals with Prepare permissions is created to give certain individuals the permission to upload changes to the asset canister. Changes must be approved through a proposal before they are applied to the asset canister.
The user or developer creating the SNS should remove their own personal permissions.
Lastly, the SNS's function should be registered to commit the configuration.
To deploy an asset canister, any canister in the dfx.json file can be set as "type": "assets", and dfx will automatically generate the required files, such as an assets.wasm.gz file and a candid/assets.did file once the canister has been built.

An example of configuring an asset canister within the dfx.json file can be found below:

    "assets": {
      "source": [],
      "type": "assets"
    }
Deploying locally for testing
To deploy your asset canister locally for testing purposes, the following command can be used:

dfx deploy assets --network "local" --no-wallet
The asset canister should be deployed and have permissions configured before the dapp is handed over to an SNS.

Deploying on the mainnet
To deploy to the mainnet, you will need a wallet that contains cycles. For more information on cycles wallets, please see here.

To deploy your asset canister to the mainnet, the following command can be used:

dfx deploy assets --network "ic" --wallet <principal>
The asset canister should be deployed and have permissions configured before the dapp is handed over to an SNS.

Configuring an asset canister's permissions
When configuring an asset canister, a set of permissions that contains a whitelist of principals must be created. This whitelist details who is allowed to submit changes that update assets in the asset canister. This whitelist must be configured prior to the SNS launch. Principals that are allowed to submit changes are given the Prepare permission.

Once a principal with Prepare permissions submits changes to the asset canister, these changes are set in a 'locked' state. Then, anyone can submit a proposal that proposes the 'locked' changes be applied; there is no permission necessary to submit this proposal.

During the SNS launch, control of the asset canister must be handed over to the SNS. Apart from assigning canister control to SNS root as with all dapp canisters, the SNS' governance canister should be added to the whitelist as a principal with Commit rights. Only principals with Commit rights may apply proposed changes.

Once the asset canister has been handed over to the SNS, only the governance canister should have Commit rights, and principals in the whitelist should have Prepare rights. The developer who configured and deployed the SNS should have their permissions removed during the SNS launch.

It is recommended that the SNS calls take_ownership via a proposal, which must be added as a custom proposal type. This will clear all permissions, and give only the SNS governance canister Commit permissions. If the SNS does not call take_ownership, a user cannot verify that all changes to the assets have been approved by an SNS proposal.

Granting permissions
To grant a principal permission within an asset canister, the following command can be used:

dfx canister call --network ic <canister-id> grant_permission <principal>
Revoking permissions
To revoke a principal's permission within an asset canister, the following command can be used:

dfx canister call --network ic <canister-id>  revoke_permission <principal>






### Testing an SNS locally

To help developers, DFINITY has created the sns-testing repo which has scripts that help developers test the SNS process. Developers can run a local version of the IC execution environment on their local machine, deploy their dapp locally and run through the stages of decentralizing their dapp.

sns-testing repo might not work for any dapp. It is intended to showcase one example dapp and so one can tweak for their own dapp.

After having chosen the initial SNS parameters in a .yaml file and before requesting an SNS launch in production, the SNS launch should be tested locally.

The main intent of sns-testing repo is for a developer to test the actual process of decentralizing their dapp.

Among other things, developers can use sns-testing repo to:

Initiate proposals.
Pass proposals.
Start decentralization swaps.
Upgrade dapp via DAO voting.
sns-testing is just one form of testing SNS process locally. Developers should feel free to use others, fork/modify sns-testing or create their own.

Using the sns-testing repo
These scripts have been most tested with a stack that looks like this:

A single canister that is being decentralized.
A canister that can be deployed to local replica via dfx deploy.
Getting started
To use the sns-testing commands and their arguments properly, you need to first set up the sns-testing repo properly. Please see README.

All of the commands in this article require sns-testing to be set up properly.
If you have started using sns-testing before August 2023 and are using the old legacy flow of launching an SNS (please see here for more context), please continue your work with the legacy documentation on this old README. In particular,
If you were following the Apple silicon-only instructions, please switch to the v1-legacy Git tag.
If you were using the Docker-based deployment approach, please use the docker image: docker pull ghcr.io/dfinity/sns-testing:v1-legacy.
Testing stages of the SNS launch process
For simplicity, next the stages introduced in the SNS launch stages documentation in the documentation commands and actions to go through SNS launch are mapped to the relevant scripts in the sns-testing repo so you can learn what part of the launch is tested in which script. Note that some developers have dapps that do not match the narrow cases of sns-testing so the table also includes a column for what other developers have experienced.

Stages
0. Deploy a dapp to the local replica.
Option 1: Testing a pre-packaged dapp created in sns-testing just for purposes of testing
./deploy_test_canister.sh
Option 2: Deploying your own single-canister dapp
dfx deploy
Option 3: Deploying your own multi-canister dapp
In this case, you should use whatever scripts or set up you have to deploy your dapp.

1. Dapp developers add NNS root as co-controller of dapp.
They can do so by running the following command:

Option 1: You have one canister

dfx sns prepare-canisters add-nns-root $CANISTER_ID
Option 3: You have many canisters, run it for each canister ID

dfx sns prepare-canisters add-nns-root $CANISTER_ID_1
dfx sns prepare-canisters add-nns-root $CANISTER_ID_2
...
dfx sns prepare-canisters add-nns-root $CANISTER_ID_N
2. Dapp developers choose the initial parameters of the SNS for a dapp.
Typically, dapp developers choose initial parameters that will be used in subsequent proposals.

Fill out this file:

example_sns_init.yaml
3. Submit NNS proposal to create SNS.
Submit an NNS proposal that ingests the example_sns_init.yaml file from stage #2

dfx sns propose --network local --neuron $NEURON_ID example_sns_init.yaml
$NEURON_ID comes from the sns-testing setup
4. The NNS proposal is decided.
Nothing technical for dapp developers to do. Community votes.

5. (Automated) SNS-W deploys SNS canisters.
Nothing technical for dapp developers to do. This is triggered automatically as a result of an adopted proposal in Stage 4.

6. (Automated) SNS-W sets SNS root as sole controller of dapp.
Nothing technical for dapp developers to do. This is triggered automatically as a result of an adopted proposal in Stage 4.

7. (Automated) SNS-W initializes SNS canisters according to settings from Step 1.
Nothing technical for dapp developers to do. This is triggered automatically as a result of an adopted proposal in Stage 4.

8. (Automated) SNS swap starts.
Nothing technical for dapp developers to do. This is triggered automatically as a result of an adopted proposal in Stage 4.

./participate_in_sns_swap.sh
9. (Automated) SNS swap ends.
Nothing technical for dapp developers to do. This is triggered automatically as a result of an adopted proposal in Stage 4.

10. (Automated) SNS swap finalizes.
Nothing technical for dapp developers to do. This is triggered automatically as a result of an adopted proposal in Stage 4.


### Testing the operation of the dapp under SNS control locally

Testing the upgrading and managing of an SNS
Once a canister or dapp has been handed over to an SNS, it will be updated via proposals and voting. Developers can test this flow by using commands from sns-testing.

Action	Example in `sns-testing`
Upgrade a yet-to-be-decentralized canister by submitting an SNS proposal that can be voted on using the SNS developer neuron.	./upgrade_test_canister.sh
Submit proposal to upgrade a decentralized canister	./upgrade_test_canister.sh
Vote on a proposal that upgrades a decentralized canister	./vote_on_sns_proposal.sh
You might also want to test integrations and basic SNS functionality. For this purpose you can use the above instructions after the test SNS is launched or use the SNS testflight on mainnet.

### How to launch your SNS on the mainnet

### Managing an SNS once launched

An introduction to managing an SNS.
An introduction to SNS proposals.
Tips regarding cycles management for the canisters.
An intorduction to how to use the asset canister with an SNS-controlled dapp.


https://internetcomputer.org/docs/current/developer-docs/integrations/sns/

## Resources

## Need help?

Did you get stuck somewhere in this tutorial, or feel like you need additional help understanding some of the concepts? The IC community has several resources available for developers, like working groups and bootcamps, along with our Discord community, forum, and events such as hackathons. Here are a few to check out:

- [Developer Discord community](https://discord.com/invite/cA7y6ezyE2), which is a large chatroom for IC developers to ask questions, get help, or chat with other developers asynchronously via text chat. 

- [Developer journey forum discussion](https://forum.dfinity.org/t/developer-journey-feedback-and-discussion/23893).

- [Developer tooling working group](https://www.google.com/calendar/event?eid=MHY0cjBubmlnYXY1cTkzZzVzcmozb3ZjZm5fMjAyMzEwMDVUMTcwMDAwWiBjX2Nnb2VxOTE3cnBlYXA3dnNlM2lzMWhsMzEwQGc&ctz=Europe/Zurich).

- [Motoko bootcamp](https://github.com/motoko-bootcamp/bootcamp-2022), a week-long crash course to learning all things Motoko. 

- [Motoko developer working group](https://www.google.com/calendar/event?eid=ZWVnb2luaHU0ZjduMTNpZHI3MWJkcWVwNWdfMjAyMzEwMTJUMTUwMDAwWiBjX2Nnb2VxOTE3cnBlYXA3dnNlM2lzMWhsMzEwQGc&ctz=Europe/Zurich).

- [Upcoming events and conferences](https://dfinity.org/events-and-news/).

- [Upcoming hackathons](https://dfinity.org/hackathons/).

- [Weekly developer office hours](https://discord.gg/4a7SZzRk?event=1164114241893187655) to ask questions, get clarification, and chat with other developers live via voice chat. This is hosted on our [developer Discord](https://discord.com/invite/cA7y6ezyE2) group.

## Next steps

- [5.6 Next steps](5.6-next-steps.md)