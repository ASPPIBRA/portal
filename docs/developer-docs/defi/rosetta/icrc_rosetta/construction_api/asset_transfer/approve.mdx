---
keywords: [intermediate, rosetta, tutorial, approve, icrc, rosetta]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Approve a spender

<MarkdownChipRow labels={["Intermediate", "Tutorial" ]} />

## Overview

This section will show you how to use the ICRC Rosetta implementation to authorize a spender to spend your ICRC-1 tokens. Make sure you are familiar with the [flow of operations](/docs/developer-docs/defi/rosetta/icp_rosetta/construction_api/operations_flow/index.mdx) for Rosetta.  
The request type that is used for making direct transfers is `APPROVE` and `SPENDER`. In the simplest form it consists of two operations, one for the the approve operation and another for the spender operation. 
Note that you do not have to specify the `FEE` operation although the `FEE` of the ICRC-1 ledger Rosetta is connected to will deduct the `FEE` automatically. 
To keep an overview of all the expenses it thus may pay off to include a `FEE` operation to not overlook unexpected debit operations. 

The minimum set of operations that is sent to the `construction/payloads` endpoint is the following. 
In this case we are approving the principal `xmiu5-jqaaa-aaaag-qbz7q-cai` to spend up to 10 e8 ckBTC from principal `iowfl-yzooa-br3dt-77erl-nlm7f-kplhq-php75-hw3an-aeqn2-swh4t-3qe`.

```bash
curl --location '0.0.0.0:8082/construction/payloads'  --header 'Content-Type: application/json' --data '{
  "network_identifier": {
    "blockchain": "Internet Computer",
    "network": "mc6ru-gyaaa-aaaar-qaaaq-cai"
  },
  "public_keys": [
    {
      "hex_bytes": "047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c757367",
      "curve_type": "secp256k1"
    }
  ],
  "operations": [
    {
      "operation_identifier": {
        "index": 0
      },
      "type": "APPROVE",
      "account": {
        "address": "iowfl-yzooa-br3dt-77erl-nlm7f-kplhq-php75-hw3an-aeqn2-swh4t-3qe",
        "sub_account": {
          "address": "0000000000000000000000000000000000000000000000000000000000000000"
        }
      },
      "amount": null,
      "metadata": {
        "allowance": {
          "value": "10",
          "currency": {
            "symbol": "ckBTC",
            "decimals": 8
          }
        },
        "expected_allowance": null,
        "expires_at": null
      }
    },
    {
      "operation_identifier": {
        "index": 1
      },
      "type": "SPENDER",
      "account": {
        "address": "xmiu5-jqaaa-aaaag-qbz7q-cai",
        "sub_account": {
          "address": "0000000000000000000000000000000000000000000000000000000000000000"
        }
      }
    }
  ],
  "metadata": null
}'

```

An example implementation of a approve operation may look like the following. 
Example call.
```bash
python3 icp_rosetta_client.py -k ~/.config/dfx/identity/default/identity.pem -u http://127.0.0.1:8082 -s ckBTC -d 8
```
```python
import json
import requests
import argparse
from hashlib import sha256
import ecdsa
from ecdsa import VerifyingKey

HEADERS = {"Content-Type": "application/json", "charset": "utf-8"}


class RosettaClient:
    # Takes in the private key an the url to the running Rosetta instance
    def __init__(self, pk, url):
        self._pk = pk
        self._url = url

    def public_key(self):
        return public_key(self._pk.verifying_key, "secp256k1")

    def sign(self, payloads):
        signatures = []
        for payload in payloads:
            data_to_sign = bytes.fromhex(payload["hex_bytes"])
            signature_bytes = self._pk.sign(data_to_sign, hashfunc=sha256).hex()
            signatures.append(
                {
                    "signing_payload": {
                        "account_identifier": payload["account_identifier"],
                        "hex_bytes": payload["hex_bytes"],
                        "signature_type": "ecdsa",
                    },
                    "signature_type": "ecdsa",
                    "public_key": self.public_key(),
                    "hex_bytes": signature_bytes,
                }
            )
        return signatures

    def network_identifier(self):
        return self.post("/network/list", {"metadata": {}})["network_identifiers"][0]

    # Makes a post request to the Rosetta instance and takes in the suffix of the endpoint of Rosetta as well as the request data
    def post(self, url_suffix, data):
        url = self._url + url_suffix
        response = requests.post(url, data=json.dumps(data), headers=HEADERS)
        return response.json()

    def construction_derive(
        self,
        public_key: str = None,
        curve_type: str = "secp256k1",
        account_type=None,
        neuron_index=0,
    ):
        metadata = None
        if public_key is None:
            public_key = self.public_key()
        if account_type is not None:
            metadata = {"account_type": account_type, "neuron_index": neuron_index}

        return self.post(
            "/construction/derive",
            {
                "network_identifier": self.network_identifier(),
                "public_key": public_key,
                "metadata": metadata,
            },
        )

    def construction_preprocess(self, operations, metadata):
        return self.post(
            "/construction/preprocess",
            {
                "operations": operations,
                "metadata": metadata,
                "network_identifier": self.network_identifier(),
            },
        )

    def construction_metadata(self, options, public_keys):
        return self.post(
            "/construction/metadata",
            {
                "network_identifier": self.network_identifier(),
                "options": options,
                "public_keys": public_keys,
            },
        )

    def construction_payload(self, public_keys, operations, metadata=None):
        data = {
            "network_identifier": self.network_identifier(),
            "public_keys": public_keys,
            "operations": operations,
        }
        data["metadata"] = metadata
        return self.post("/construction/payloads", data)

    def construction_combine(self, unsigned_transaction, signatures):
        return self.post(
            "/construction/combine",
            {
                "network_identifier": self.network_identifier(),
                "unsigned_transaction": unsigned_transaction,
                "signatures": signatures,
            },
        )

    def construction_submit(self, signed_transaction: str):
        return self.post(
            "/construction/submit",
            {
                "network_identifier": self.network_identifier(),
                "signed_transaction": signed_transaction,
            },
        )

    def make_and_submit_transaction(self, operations):
        public_keys = [self.public_key()]
        result = self.construction_payload(public_keys, operations)
        print(result)
        signatures = self.sign(result["payloads"])
        signed_transaction = self.construction_combine(
            result["unsigned_transaction"], signatures
        )
        return self.construction_submit(signed_transaction["signed_transaction"])


def icrc1_token_amount(amount: int, token_symbol="ckBTC", decimals=8):
    return {
        "value": f"{amount}",
        "currency": {"symbol": token_symbol, "decimals": decimals},
    }

def public_key(public_key=VerifyingKey, curve_type="secp256k1"):
    return {
        "hex_bytes": public_key.to_string("uncompressed").hex(),
        "curve_type": curve_type,
    }

def icrc2_approve_operation(
    index: int,
    allowance: int,
    principal: str,
    subaccount="0000000000000000000000000000000000000000000000000000000000000000",
    expected_allowance = None,
    expires_at = None,
    symbol="ckBTC",
    decimals=8,
):
    return {
        "operation_identifier": {"index": index},
        "type": "APPROVE",
        "account": {
            "address": principal,
            "sub_account": {
                "address": subaccount
            },
        },
        # The amount is left empty because an approval does not yet transfer any tokens
        "amount": None,
        "metadata": {
            'allowance': icrc1_token_amount(allowance, symbol, decimals),
            'expected_allowance': icrc1_token_amount(expected_allowance, symbol, decimals) if expected_allowance else None,
            'expires_at':expires_at
        }
    }

def icrc2_spender_operation(
    index: int,
    spender_principal: str,
    subaccount="0000000000000000000000000000000000000000000000000000000000000000"
):
    return {
        "operation_identifier": {"index": index},
        "type": "SPENDER",
        "account": {
            "address": spender_principal,
            "sub_account": {
                "address": subaccount
            },
        }
    }

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-k", "--private-key-file", required=True)
    parser.add_argument("-hk", "--hot-key-private-key-file", required=False)
    parser.add_argument("-u", "--ic-url", required=True)
    parser.add_argument("-is", "--ingress-start", required=False)
    parser.add_argument("-ie", "--ingress-end", required=False)
    parser.add_argument("-m", "--memo", required=False)
    parser.add_argument("-s", "--symbol", required=True)
    parser.add_argument("-d", "--decimals", required=True)
    parser.add_argument("-c", "--created-at-time", required=False)
    return parser.parse_args()


def main():
    args = parse_args()
    with open(args.private_key_file, "rb") as key_file:
        private_key = ecdsa.SigningKey.from_pem(key_file.read())
    client = RosettaClient(private_key, args.ic_url)

    approver_principal = client.construction_derive(client.public_key())[
        "account_identifier"
    ]["address"]
    
    spender_principal = "xmiu5-jqaaa-aaaag-qbz7q-cai"
    token_amount = 10
    
    approver_ops = icrc2_approve_operation(
        index = 0, allowance = token_amount, principal = approver_principal, symbol = args.symbol, decimals = int(args.decimals)
    )
    spender_ops = icrc2_spender_operation(
        1, spender_principal
    )
    
    print(
        json.dumps(
            client.make_and_submit_transaction(
                [approver_ops, spender_ops]
            ),
            indent=2,
        )
    )


if __name__ == "__main__":
    main()

```