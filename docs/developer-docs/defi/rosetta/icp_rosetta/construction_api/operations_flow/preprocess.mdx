---
keywords: [intermediate, rosetta, tutorial, derive, accountidentifier]
---
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Construction-Preprocess

## How to acquire network specific metadata
This section details how to call the `construction/preprocess` endpoint of the Rosetta construction API.
Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction. The ICP Rosetta implementation will return the required list of public keys that has to be provided by the user and in the metadata it returns the request type that is associated with the given set of operations. 
The metadata returned from this endpoint will be sent to the /construction/metadata endpoint UNMODIFIED by the caller (in an offline execution environment). 
The request and response types can be found in the [official documentation](https://docs.cloud.coinbase.com/rosetta/reference/constructionpreprocess).

An example of a call to the preprocess endpoint would look like the following. Here we are creating two operations, one for debiting the account that the tokens are sent from and a credit operation for the account where the tokens are sent to. 
For this example we are sending ICP to the arbitrary account `082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5`. 
```bash
curl --location '0.0.0.0:8081/construction/preprocess'  --header 'Content-Type: application/json' --data '{
  "network_identifier": {
    "blockchain": "Internet Computer",
    "network": "00000000000000020101"
  },
  "operations": [
    {
      "operation_identifier": {
        "index": 0
      },
      "type": "TRANSACTION",
      "account": {
        "address": "8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"
      },
      "amount": {
        "value": "-10",
        "currency": {
          "symbol": "ICP",
          "decimals": 8
        }
      }
    },
    {
      "operation_identifier": {
        "index": 1
      },
      "type": "TRANSACTION",
      "account": {
        "address": "082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5"
      },
      "amount": {
        "value": "10",
        "currency": {
          "symbol": "ICP",
          "decimals": 8
        }
      }
    }
  ],
  "metadata": null
}'
```

and the response would look something like this. It contains two fields. The `options` object has to be forwarded to the `construction/metadata` endpoint to fetch network specific data. 
The `required_public_keys` field indicates for which `account-id` the `construction/payloads` endpoint will need the full public key. 

```json
{"options":{"request_types":["TRANSACTION"]},"required_public_keys":[{"address":"8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"}]}‚èé                                                                  
```
The required public keys in this case is the public key that correspons to the sending account. We can derive this public key from the provided private key. To validate that the accountidentifiers match up you can call `construction/derive` with the public key.
Building on the previous python code snipped. A call to the `construction/preprocess` endpoint written in python could be implemented like the following.

Example call: 
```bash
python3 icp_rosetta_client.py -k ~/.config/dfx/identity/default/identity.pem -u http://127.0.0.1:8081
```

```python
import json
import requests
import argparse
import ecdsa

NETWORK_ID={'blockchain': 'Internet Computer', 'network': '00000000000000020101'}
HEADERS={'Content-Type': 'application/json', 'charset': 'utf-8'}

class RosettaClient:
    # Takes in the private key an the url to the running Rosetta instance
    def __init__(self, pk, url):
        self._pk = pk
        self._url = url
    
    def public_key(self):
        return {
            "hex_bytes": self._pk.verifying_key.to_string("uncompressed").hex(),
            "curve_type": "secp256k1",
        }
    
    # Makes a post request to the Rosetta instance and takes in the suffix of the endpoint of Rosetta as well as the request data
    def post(self, url_suffix, data):
        url = self._url + url_suffix
        response = requests.post(url, data=json.dumps(data), headers=HEADERS)
        return response.json()
    
    def construction_derive(self, public_key: str = None, curve_type: str = 'secp256k1'):
        if public_key is None:
            public_key = self.public_key()
        return self.post('/construction/derive', build_data({
            'public_key': public_key
        }))
    
    def construction_preprocess(self, operations, metadata):
        return self.post('/construction/preprocess', build_data({
            'operations': operations,
            'metadata': metadata,
            'network_identifier': NETWORK_ID
        }))
    


def icp_amount(amount: int):
    return {
        "value": f'{amount}',
        "currency": { "symbol": "ICP", "decimals": 8 }
    }

def transfer_operation(index: int, account_id: str, amount: int):
    return {
        "operation_identifier": { "index": index },
        "type": "TRANSACTION",
        "account": { "address": account_id },
        "amount": icp_amount(amount)
    }

# Attaches the network_identifier to the request
def build_data(d):
    return { 'network_identifier': NETWORK_ID, **d }


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-k', '--private-key-file', required=True)
    parser.add_argument('-u', '--ic-url', required=True)
    return parser.parse_args()

def main():
    args = parse_args()
    with open(args.private_key_file, "rb") as key_file:
        private_key = ecdsa.SigningKey.from_pem(key_file.read())

    client = RosettaClient(private_key, args.ic_url)

    # We derive the account identifier from the public key of the provided private key
    from_account = client.construction_derive(client.public_key())['account_identifier']['address']
    
    # An arbitrary accountidentifier to send the ICP to
    to_account = "082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5"
    
    # We are going to send 10 ICP in this example
    icp_amount = 10
    
    # We create the necessary operations for the transfer
    from_operation = transfer_operation(0, from_account, -icp_amount)
    to_operation = transfer_operation(1, to_account, icp_amount)
    
    print(client.construction_preprocess([from_operation, to_operation], None))

if __name__=='__main__':
    main()
```