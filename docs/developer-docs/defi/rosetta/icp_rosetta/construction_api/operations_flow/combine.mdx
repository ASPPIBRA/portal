---
keywords: [intermediate, rosetta, tutorial, derive, accountidentifier]
---
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Construction-Combine

## How to sign Payloads and create a valid Signed Transaction
This section details how to call the `construction/combine` endpoint of the Rosetta construction API.
The request and response types can be found in the [official documentation](https://docs.cloud.coinbase.com/rosetta/reference/constructioncombine).

### Signing Payloads
The payloads that one receives from the `construction/payloads` endpoint contain a hex string that needs to be signed with the private key of the accountidentifier that is associated with the hex string. 
Here is an example of such a payload:
```json
{"account_identifier":{"address":"8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"},"hex_bytes":"0a69632d72657175657374df3e33267733b2030e8a4fc1d7eb6e0884ab461806630921a9c0c9749abb99de","signature_type":"ecdsa"}
```
This means that we need to sign the hex bytes `0a69632d72657175657374df3e33267733b2030e8a4fc1d7eb6e0884ab461806630921a9c0c9749abb99de` with the private key associated with the accountidentifier 
`8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4` using an `ecdsa` signature type.
A code snipped on how to do this is provided could look like the following:
```python
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes

    def sign(client:RosettaClient, payloads):
        signatures = []
        for payload in payloads:
            data_to_sign = bytes.fromhex(payload["hex_bytes"])
            digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
            digest.update(data_to_sign)
            hashed_data = digest.finalize()
            # Sign the hashed data
            signature_bytes = client._pk.sign(
                hashed_data, ec.ECDSA(hashes.SHA256())
            ).hex()
            signatures.append(
                {
                    "signing_payload": {
                        "account_identifier": payload["account_identifier"],
                        "hex_bytes": payload["hex_bytes"],
                    },
                    "signature_type": "ecdsa",
                    "public_key": client.public_key(),
                    "hex_bytes": signature_bytes,
                }
            )
        return signatures
```
This function will return a signed payload that looks like this:

```json
[{'signing_payload': {'account_identifier': {'address': '8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4'}, 'hex_bytes': '0a69632d72657175657374df3e33267733b2030e8a4fc1d7eb6e0884ab461806630921a9c0c9749abb99de'}, 'signature_type': 'ecdsa', 'public_key': {'hex_bytes': '047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c757367', 'curve_type': 'secp256k1'}, 'hex_bytes': '3046022100ce0807d84c8321bf3525361ad25654be81076e75e8c004970789d385f195fc500221008eebd282efabb878ac54e77dc4230acf54d103ef05253db44cb9fba0fb382764'}, {'signing_payload': {'account_identifier': {'address': '8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4'}, 'hex_bytes': '0a69632d726571756573746aacd6e73f46e366079c0963e43ff82eae216a52ddaf45d1bb3838540946a446'}, 'signature_type': 'ecdsa', 'public_key': {'hex_bytes': '047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c757367', 'curve_type': 'secp256k1'}, 'hex_bytes': '30440220344e98df1f20bd1667b06640b2f078459944eaedb89e139930e618cac9b9ef6202206c938d49f01d9a8457719351d7917e6640405030bacf2f46c9cf250f7d45df0a'}]
```
It provides the original payload that was signed as well as the resulting signature. In this example the original signable hex bytes `0a69632d72657175657374df3e33267733b2030e8a4fc1d7eb6e0884ab461806630921a9c0c9749abb99de`
result in the signature in hex representation `3046022100ce0807d84c8321bf3525361ad25654be81076e75e8c004970789d385f195fc500221008eebd282efabb878ac54e77dc4230acf54d103ef05253db44cb9fba0fb382764`.
For every payload a signature in hex representation has be created. Using the unsigned transaction and the list of valid signatures, the `construction/combine` endpoint can be called. 

### Fetching a signed transaction
The `construction/combine` endpoint will create a signed transaction and return it. A call to the endpoint may look like the following. 
```bash
curl --location '0.0.0.0:8081/construction/preprocess'  --header 'Content-Type: application/json' --data '{
  "network_identifier": {
    "blockchain": "Internet Computer",
    "network": "00000000000000020101"
  },
  "unsigned_transaction": "a2677570646174657381826b5452414e53414354494f4ea56b63616e69737465725f69644a000000000000000201016b6d6574686f645f6e616d656773656e645f70626361726758470a0a08dbcad48da0e59fcc2a12040a02080a1a0308904e2a220a20082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b53a0a0882c4d9c7f2e7fddf176673656e646572581d2e70031d8e7ff922b6ad9f2a9eb3c1e77ffa7b6c0d0120dd4ac7e4f7026e696e67726573735f6578706972790070696e67726573735f6578706972696573811b17bff7770a13b3d4",
  "signatures": [
    {
      "signing_payload": {
        "account_identifier": {
          "address": "8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"
        },
        "hex_bytes": "0a69632d72657175657374016476cbd81fe57ec0c1094c8a82251b6a009a413366b778a68c2d9a08a749df"
      },
      "signature_type": "ecdsa",
      "public_key": {
        "hex_bytes": "047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c757367",
        "curve_type": "secp256k1"
      },
      "hex_bytes": "30460221009b3a8b53b6cf502fdd396d672b68895abf3011559783d070c5e460d07ef0954302210099c9dbf6fea928684c355f354427e84a8abce62d4446a3d9519917e3f865773b"
    },
    {
      "signing_payload": {
        "account_identifier": {
          "address": "8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"
        },
        "hex_bytes": "0a69632d72657175657374ef6730430b456552fefafbc87b35bbba8b316316b82d69f6b29ea148d4640bb1"
      },
      "signature_type": "ecdsa",
      "public_key": {
        "hex_bytes": "047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c757367",
        "curve_type": "secp256k1"
      },
      "hex_bytes": "30440220679d82b60f97be4961865d7067fa4f40737dcae5f72d4d564a82798f5cf50bea022006b76f63e7a02208a26069cc05704d5997ca7234c541800542f31919bdd49429"
    }
  ]
}'
```

and the response would look something like this.

```json
{'signed_transaction': 'a168726571756573747381826b5452414e53414354494f4e81a266757064617465a367636f6e74656e74bf6c726571756573745f747970656463616c6c6b63616e69737465725f69644a000000000000000201016b6d6574686f645f6e616d656773656e645f70626361726758470a0a08dbcad48da0e59fcc2a12040a02080a1a0308904e2a220a20082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b53a0a0882c4d9c7f2e7fddf176673656e646572581d2e70031d8e7ff922b6ad9f2a9eb3c1e77ffa7b6c0d0120dd4ac7e4f7026e696e67726573735f6578706972791b17bff7770a13b3d4ff6d73656e6465725f7075626b657958583056301006072a8648ce3d020106052b8104000a034200047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c7573676a73656e6465725f736967584830460221009b3a8b53b6cf502fdd396d672b68895abf3011559783d070c5e460d07ef0954302210099c9dbf6fea928684c355f354427e84a8abce62d4446a3d9519917e3f865773b6a726561645f7374617465a367636f6e74656e74bf6c726571756573745f747970656a726561645f73746174656673656e646572581d2e70031d8e7ff922b6ad9f2a9eb3c1e77ffa7b6c0d0120dd4ac7e4f70265706174687381824e726571756573745f7374617475735820016476cbd81fe57ec0c1094c8a82251b6a009a413366b778a68c2d9a08a749df6e696e67726573735f6578706972791b17bff7770a13b3d4ff6d73656e6465725f7075626b657958583056301006072a8648ce3d020106052b8104000a034200047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c7573676a73656e6465725f736967584630440220679d82b60f97be4961865d7067fa4f40737dcae5f72d4d564a82798f5cf50bea022006b76f63e7a02208a26069cc05704d5997ca7234c541800542f31919bdd49429'}
```
Building on the previous python code snipped. A call to the `construction/combine` endpoint written in python could be implemented like the following.

Example call: 
```bash
python3 icp_rosetta_client.py -k ~/.config/dfx/identity/default/identity.pem -u http://127.0.0.1:8081
```

```python
import json
import requests
import argparse
import ecdsa
from hashlib import sha256

NETWORK_ID = {"blockchain": "Internet Computer", "network": "00000000000000020101"}
HEADERS = {"Content-Type": "application/json", "charset": "utf-8"}


class RosettaClient:
    # Takes in the private key an the url to the running Rosetta instance
    def __init__(self, pk, url):
        self._pk = pk
        self._url = url

    def public_key(self):
        return {
            "hex_bytes": self._pk.verifying_key.to_string("uncompressed").hex(),
            "curve_type": "secp256k1",
        }

    def sign(self, payloads):
        signatures = []
        for payload in payloads:
            data_to_sign = bytes.fromhex(payload["hex_bytes"])
            signature_bytes = self._pk.sign(data_to_sign,hashfunc=sha256).hex()
            signatures.append(
                {
                    "signing_payload": {
                        "account_identifier": payload["account_identifier"],
                        "hex_bytes": payload["hex_bytes"],
                        'signature_type': 'ecdsa',
                    },
                    "signature_type": "ecdsa",
                    "public_key": self.public_key(),
                    "hex_bytes": signature_bytes,
                }
            )
        return signatures

    # Makes a post request to the Rosetta instance and takes in the suffix of the endpoint of Rosetta as well as the request data
    def post(self, url_suffix, data):
        url = self._url + url_suffix
        response = requests.post(url, data=json.dumps(data), headers=HEADERS)
        return response.json()

    def construction_derive(
        self, public_key: str = None, curve_type: str = "secp256k1"
    ):
        if public_key is None:
            public_key = self.public_key()
        return self.post("/construction/derive", build_data({"public_key": public_key}))

    def construction_preprocess(self, operations, metadata):
        return self.post(
            "/construction/preprocess",
            build_data(
                {
                    "operations": operations,
                    "metadata": metadata,
                    "network_identifier": NETWORK_ID,
                }
            ),
        )

    def construction_metadata(self, options, public_keys):
        return self.post(
            "/construction/metadata",
            build_data(
                {
                    "options": options,
                    "public_keys": public_keys,
                }
            ),
        )

    def construction_payload(self, public_keys, operations, metadata=None):
        data = build_data(
            {
                "public_keys": public_keys,
                "operations": operations,
            }
        )
        data["metadata"] = metadata
        return self.post("/construction/payloads", data)

    def construction_combine(self, unsigned_transaction, signatures):
        return self.post(
            "/construction/combine",
            build_data(
                {
                    "unsigned_transaction": unsigned_transaction,
                    "signatures": signatures,
                }
            ),
        )


def icp_amount(amount: int):
    return {"value": f"{amount}", "currency": {"symbol": "ICP", "decimals": 8}}


def fee_operation(index: int, account_id: str, fee: int):
    return {
        "operation_identifier": {"index": index},
        "type": "FEE",
        "account": {"address": account_id},
        "amount": icp_amount(-fee),
    }


def transfer_operation(index: int, account_id: str, amount: int):
    return {
        "operation_identifier": {"index": index},
        "type": "TRANSACTION",
        "account": {"address": account_id},
        "amount": icp_amount(amount),
    }


# Attaches the network_identifier to the request
def build_data(d):
    return {"network_identifier": NETWORK_ID, **d}


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-k", "--private-key-file", required=True)
    parser.add_argument("-u", "--ic-url", required=True)
    parser.add_argument("-is", "--ingress-start", required=False)
    parser.add_argument("-ie", "--ingress-end", required=False)
    parser.add_argument("-m", "--memo", required=False)
    parser.add_argument("-c", "--created-at-time", required=False)
    return parser.parse_args()


def main():
    args = parse_args()
    with open(args.private_key_file, "rb") as key_file:
        private_key = ecdsa.SigningKey.from_pem(key_file.read())
    client = RosettaClient(private_key, args.ic_url)

    # We derive the account identifier from the public key of the provided private key
    from_account = client.construction_derive(client.public_key())[
        "account_identifier"
    ]["address"]

    # An arbitrary accountidentifier to send the ICP to
    to_account = "082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5"

    # We are going to send 10 ICP in this example
    icp_amount = 10

    # We create the necessary operations for the transfer
    from_operation = transfer_operation(0, from_account, -icp_amount)
    to_operation = transfer_operation(1, to_account, icp_amount)

    options = client.construction_preprocess([from_operation, to_operation], None)[
        "options"
    ]
    public_keys = [client.public_key()]

    # We get the suggested fee from the Rosetta instance
    fee = int(
        client.construction_metadata(options, public_keys)["suggested_fee"][0]["value"]
    )
    fee_ops = fee_operation(2, from_account, fee)

    result = client.construction_payload(
        public_keys,
        [from_operation, to_operation, fee_ops],
        {
            "created_at_time": int(args.created_at_time)
            if args.created_at_time
            else None,
            "memo": int(args.memo) if args.memo else None,
            "ingress_start": int(args.ingress_start) if args.ingress_start else None,
            "ingress_end": int(args.ingress_end) if args.ingress_end else None,
        },
    )
    signatures = client.sign(result["payloads"])
    print(client.construction_combine(result["unsigned_transaction"], signatures))

if __name__ == "__main__":
    main()
```