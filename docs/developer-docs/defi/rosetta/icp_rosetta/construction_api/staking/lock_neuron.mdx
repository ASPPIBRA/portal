---
keywords: [intermediate, rosetta, tutorial, spawn, neuron, staking, lock]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Lock a neuron

<MarkdownChipRow labels={["Intermediate", "Tutorial" ]} />

## Overview
In this section of the staking tutorial you will learn how to lock your neuron. The amount of rewards you can expect to receive are amongst other factors dependent on the amount of time a neuron is locked up for. 
If the dissolve timestamp is set to a value that is before 6 months in the future you will not be getting any rewards for the locked period. This is because 
the last 6 months of a dissolving neuron, the neuron will not get any rewards. So if you set the dissolve timestamp to 1 year in the future and start dissolving the neuron right away, you will receive rewards for the next 6 months. 

The dissolve timestamp always increases monotonically.

-   If the neuron is in the `DISSOLVING` state, this operation can move the dissolve timestamp further into the future.

-   If the neuron is in the `NOT_DISSOLVING` state, invoking `SET_DISSOLVE_TIMESTAMP` with time T will attempt to increase the neuronâ€™s dissolve delay (the minimal time it will take to dissolve the neuron) to `T - current_time`.

-   If the neuron is in the `DISSOLVED` state, invoking `SET_DISSOLVE_TIMESTAMP` will move it to the `NOT_DISSOLVING` state and will set the dissolve delay accordingly.

The example call to the `construction/payloads` endpoint looks like the following. 

```bash
curl --location '0.0.0.0:8081/construction/payloads'  --header 'Content-Type: application/json' --data '{
  "network_identifier": {
    "blockchain": "Internet Computer",
    "network": "00000000000000020101"
  },
  "public_keys": [
    {
      "hex_bytes": "047a83e378053f87b49aeae53b3ed274c8b2ffbe59d9a51e3c4d850ca8ac1684f7131b778317c0db04de661c7d08321d60c0507868af41fe3150d21b3c6c757367",
      "curve_type": "secp256k1"
    }
  ],
  "operations": [
    {
      "operation_identifier": {
        "index": 4
      },
      "type": "SET_DISSOLVE_TIMESTAMP",
      "account": {
        "address": "8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"
      },
      "metadata": {
        "neuron_index": 0,
        "dissolve_time_utc_seconds": 1712156627
      }
    }
  ],
  "metadata": null
}'
```

The response will confirm that the dissolve timestamp has been changed.
```json
{
    "transaction_identifier": {
        "hash": "0000000000000000000000000000000000000000000000000000000000000000"
    },
    "metadata": {
        "operations": [
            {
                "account": {
                    "address": "8b84c3a3529d02a9decb5b1a27e7c8d886e17e07ea0a538269697ef09c2a27b4"
                },
                "metadata": {
                    "dissolve_time_utc_seconds": 1712156627,
                    "neuron_index": 0
                },
                "operation_identifier": {
                    "index": 0
                },
                "status": "COMPLETED",
                "type": "SET_DISSOLVE_TIMESTAMP"
            }
        ]
    }
}
```

If you then check the neuron you will see that it changed state from `DISSOLVED` to `NOT_DISSOLVING`. If you set the timestamp to a sufficiently far time in the future you can now start to collect rewards for with your neuron. 
An example implementation of the rosetta client may look like the following. 

Example call.
```bash
python3 icp_rosetta_client.py -k ~/.config/dfx/identity/default/identity.pem -u http://127.0.0.1:8081
```

```python3
import json
import requests
import argparse
from hashlib import sha256
import ecdsa
import time

NETWORK_ID = {"blockchain": "Internet Computer", "network": "00000000000000020101"}
HEADERS = {"Content-Type": "application/json", "charset": "utf-8"}


class RosettaClient:
    # Takes in the private key an the url to the running Rosetta instance
    def __init__(self, pk, url):
        self._pk = pk
        self._url = url

    def public_key(self):
        return {
            "hex_bytes": self._pk.verifying_key.to_string("uncompressed").hex(),
            "curve_type": "secp256k1",
        }

    def sign(self, payloads):
        signatures = []
        for payload in payloads:
            data_to_sign = bytes.fromhex(payload["hex_bytes"])
            signature_bytes = self._pk.sign(data_to_sign, hashfunc=sha256).hex()
            signatures.append(
                {
                    "signing_payload": {
                        "account_identifier": payload["account_identifier"],
                        "hex_bytes": payload["hex_bytes"],
                        "signature_type": "ecdsa",
                    },
                    "signature_type": "ecdsa",
                    "public_key": self.public_key(),
                    "hex_bytes": signature_bytes,
                }
            )
        return signatures

    # Makes a post request to the Rosetta instance and takes in the suffix of the endpoint of Rosetta as well as the request data
    def post(self, url_suffix, data):
        url = self._url + url_suffix
        response = requests.post(url, data=json.dumps(data), headers=HEADERS)
        return response.json()

    def construction_derive(
        self, public_key: str = None, curve_type: str = "secp256k1", account_type = None, neuron_index = 0
    ):  
        metadata = None
        if public_key is None:
            public_key = self.public_key()
        if account_type is not None:
            metadata = {"account_type": account_type, "neuron_index": neuron_index}
            
        return self.post("/construction/derive", build_data({"public_key": public_key, "metadata": metadata}))

    def construction_payload(self, public_keys, operations, metadata=None):
        data = build_data(
            {
                "public_keys": public_keys,
                "operations": operations,
            }
        )
        data["metadata"] = metadata
        return self.post("/construction/payloads", data)

    def construction_combine(self, unsigned_transaction, signatures):
        return self.post(
            "/construction/combine",
            build_data(
                {
                    "unsigned_transaction": unsigned_transaction,
                    "signatures": signatures,
                }
            ),
        )

    def construction_submit(self, signed_transaction: str):
        return self.post(
            "/construction/submit",
            build_data(
                {
                    "signed_transaction": signed_transaction,
                }
            ),
        )
    
    def make_and_submit_transaction(self, operations):
        public_keys = [self.public_key()]
        result = self.construction_payload(public_keys, operations)
        signatures = self.sign(result["payloads"])
        signed_transaction = self.construction_combine(
            result["unsigned_transaction"], signatures
        )
        return self.construction_submit(signed_transaction["signed_transaction"])
    
def neuron_info_operation(address,neuron_index = 0, controller = None, operation_identifier = 0):
    return {
      "operation_identifier": { "index": operation_identifier },
      "type": "NEURON_INFO",
      "account": {
        "address": address
      },
      "metadata": {
        "neuron_index": neuron_index,
        "controller": controller
      }
    }

def set_dissolve_timestamp_operation(address,neuron_index = 0, controller = None, operation_identifier = 0, dissolve_time_utc_seconds = int(time.time())):
     return   {
    "operation_identifier": { "index": 4 },
    "type": "SET_DISSOLVE_TIMESTAMP",
    "account": {
        "address": address
    },
    "metadata": {
        "neuron_index": neuron_index,
        "dissolve_time_utc_seconds": dissolve_time_utc_seconds
    }
    }

# Attaches the network_identifier to the request
def build_data(d):
    return {"network_identifier": NETWORK_ID, **d}


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-k", "--private-key-file", required=True)
    parser.add_argument("-u", "--ic-url", required=True)
    parser.add_argument("-is", "--ingress-start", required=False)
    parser.add_argument("-ie", "--ingress-end", required=False)
    parser.add_argument("-m", "--memo", required=False)
    parser.add_argument("-c", "--created-at-time", required=False)
    return parser.parse_args()


def main():
    args = parse_args()
    with open(args.private_key_file, "rb") as key_file:
        private_key = ecdsa.SigningKey.from_pem(key_file.read())
    client = RosettaClient(private_key, args.ic_url)
    
    set_dissolve_timestamp_ops = set_dissolve_timestamp_operation(client.construction_derive()["account_identifier"]["address"],dissolve_time_utc_seconds=int(time.time()+100))
    print(json.dumps(client.make_and_submit_transaction([set_dissolve_timestamp_ops]),indent=4))
    
    neuron_info_ops = neuron_info_operation(client.construction_derive()["account_identifier"]["address"])
    print(json.dumps(client.make_and_submit_transaction([neuron_info_ops]),indent=4))


if __name__ == "__main__":
    main()

```