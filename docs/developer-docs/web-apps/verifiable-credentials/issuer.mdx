---
keywords: [intermediate, tutorial, identity, credentials, verifiable credentials, issuer]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import useBaseUrl from "@docusaurus/useBaseUrl";

# Become an issuer

<MarkdownChipRow labels={["Intermediate", "Tutorial"]} />

## Overview

An **issuer** is a service or app that can issue a verifiable credential to a user. To become an issuer, your canister must implement the verifiable credential interface using the issuer API. The issuer API is used to issue verifiable credentials, while another API, the identity provider API, is used to communicate with an identity provider such as Internet Identity. End-users communicate with the identity provider for authentication and to consent to being issued a verifiable credential. An identity provider is also used to relay information between the issuer and the [relying party](relying-party.mdx) when a verifiable credential is requested by the relying party.

Internet Identity is used as the identity provider in this tutorial.

## Using the issuer API

To use the issuer API, your canister must support four steps that are required to issue a verifiable credential:

1. Obtain a consent message (API endpoint `vc_consent_message`): Receive a message of consent from identity provider to issue a user a verifiable credential.

2. Implement a derivation origin (API endpoint `derivation_origin`): Configure an alternative origin URL that the identity provider may send the request from and still be considered valid.

3. Prepare the credentials (API endpoint `prepare_credential`): Prepare the credentials for the requested user.

4. Issue the credential (API endpoint `get_credential`): Verify the credential and officially issue it to the user.

### Step 1: Obtain a consent message (`vc_consent_message`)

First, the user must send a consent message to the issuer using the `vc_consent_message` API endpoint through the identity provider. A consent message is an approval from the user to validate that they consent to the issuing of a VC.

An example implementation in Rust can be found below:

```rust
pub fn get_vc_consent_message_en(
    credential_spec: &CredentialSpec,
) -> Result<Icrc21ConsentInfo, Icrc21Error> {
    match verify_spec_and_get_group_name(credential_spec) {
        Err(err) => Err(Icrc21Error::ConsentMessageUnavailable(Icrc21ErrorInfo {
            description: err,
        })),
        Ok((group_name, _owner)) => Ok(Icrc21ConsentInfo {
            consent_message: format!("# \"{}\"", group_name),
            language: "en".to_string(),
        }),
    }
}
```

If the response is an approval, the identity provider returns the consent message to the issuer.

### Step 2: Implement a derivation origin (`derivation_origin`)

Next, the issuer must implement the `derivation_origin` API endpoint, which enables support of the [alternative derivation origins](https://internetcomputer.org/docs/current/references/ii-spec#alternative-frontend-origins) feature.

A derivation origin is an alternative URL that can be obtained by the identity provider for the user's principal. If the issuer does not implement alternative derivation origins, the identity provider will return the default value of the canister's URL (`https://<issuer-canister-id>.icp0.io`).

This endpoint verifies that a user's principal, if issued by an alternative origin, is valid and can be issued a verifiable credential.

An example implementation in Rust can be found below:

```rust
async fn derivation_origin(
    req: DerivationOriginRequest,
) -> Result<DerivationOriginData, DerivationOriginError> {
    get_derivation_origin(&req.frontend_hostname)
}

fn get_derivation_origin(_hostname: &str) -> Result<DerivationOriginData, DerivationOriginError> {
    CONFIG.with_borrow(|config| {
        let config = config.get();
        println!("*** derivation origin: {}", config.derivation_origin);
        Ok(DerivationOriginData {
            origin: config.derivation_origin.clone(),
        })
    })
}
```

:::info
The returned derivation origin is subject to verification via `.well-known/ii-alternative-origins`, as described in the [feature description](https://internetcomputer.org/docs/current/references/ii-spec#alternative-frontend-origins).
:::

### Step 3: Prepare the credentials (`prepare_credential`)

Before a credential can be issued, the request for the credential must be checked for validity using the `prepare_credential` API endpoint. Once it has been validated, then the actual VC can be prepared. The issuer validates the request through the `signed_id_alias.credential_jws` token. If this check is successful, the issuer prepares the credential data and returns it in `PreparedCredentialData.prepared_context`.

An example implementation in Rust can be found below:

```rust
fn prepare_credential_jwt(
    credential_spec: &CredentialSpec,
    alias_tuple: &AliasTuple,
) -> Result<String, IssueCredentialError> {
    let (group_name, owner) = verify_spec_and_get_group_name(credential_spec)
        .map_err(IssueCredentialError::UnsupportedCredentialSpec)?;
    GROUPS.with_borrow(|groups| {
        verify_principal_is_member(alias_tuple.id_dapp, group_name, owner, groups)
    })?;
    Ok(verified_member_credential(
        alias_tuple.id_alias,
        credential_spec,
    ))
}
```

:::info
The value of `prepared_context` is used to transfer information between the `prepare_credential` and `get_credential` steps. It is up to the issuer to decide on the content of this field since the issuer creates `prepared_context` and is the only entity that consumes it.

For example, when using [canister signatures](https://internetcomputer.org/docs/current/references/ic-interface-spec#canister-signatures)
`prepared_context` contains a time stamped and unsigned VC, for which the canister signature will be available through the `get_credential` call.
:::

### Step 4: Issue the credential (`get_credential`)

Lastly, the issuer must implement the `get_credential` API endpoint to issue the credential requested by the user. The issuer performs the same checks used to prepare the credential, with an additional verify step to confirm that `prepared_context` is consistent with `prepare_credential`. If successful, the issuer returns the signed credential in JWS-format.

An example implementation in Rust can be found below:

```rust
#[query]
#[candid_method(query)]
fn get_credential(req: GetCredentialRequest) -> Result<IssuedCredentialData, IssueCredentialError> {
    if let Err(err) = authorize_vc_request(&req.signed_id_alias, &caller(), time().into()) {
        return Result::<IssuedCredentialData, IssueCredentialError>::Err(err);
    };
    let prepared_context = match req.prepared_context {
        Some(context) => context,
        None => {
            return Result::<IssuedCredentialData, IssueCredentialError>::Err(internal_error(
                "missing prepared_context",
            ))
        }
    };
    let credential_jwt = match String::from_utf8(prepared_context.into_vec()) {
        Ok(s) => s,
        Err(_) => {
            return Result::<IssuedCredentialData, IssueCredentialError>::Err(internal_error(
                "invalid prepared_context",
            ))
        }
    };
    let signing_input =
        vc_signing_input(&credential_jwt, &CANISTER_SIG_PK).expect("failed getting signing_input");
    let message_hash = vc_signing_input_hash(&signing_input);
    let sig_result = SIGNATURES.with(|sigs| {
        let sig_map = sigs.borrow();
        let certified_assets_root_hash = ASSETS.with_borrow(|assets| assets.root_hash());
        sig_map.get_signature_as_cbor(
            &CANISTER_SIG_SEED,
            message_hash,
            Some(certified_assets_root_hash),
        )
    });
    let sig = match sig_result {
        Ok(sig) => sig,
        Err(e) => {
            return Result::<IssuedCredentialData, IssueCredentialError>::Err(
                IssueCredentialError::SignatureNotFound(format!(
                    "signature not prepared or expired: {}",
                    e
                )),
            );
        }
    };
    let vc_jws =
        vc_jwt_to_jws(&credential_jwt, &CANISTER_SIG_PK, &sig).expect("failed constructing JWS");
    Result::<IssuedCredentialData, IssueCredentialError>::Ok(IssuedCredentialData { vc_jws })
}
```

## Resources

- [Verifiable credentials specification](https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md).

- [Issuer demo](https://github.com/dfinity/vc-playground/blob/main/issuer/src/main.rs).

- [Verifiable credentials playground: Issuer](https://metaissuer.vc/).

- [Verifiable credentials playground: Relying party](https://relyingparty.vc/).
