---
keywords: [security, concept, denial of service, dos, cycles, captcha]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Security Best Practices: Denial of Service

<MarkdownChipRow labels={["Intermediate", "Security", "Concept"]} />


## Protect Against DoS and DDoS Attacks

### Security Concern

A Denial of Service (DoS) attack aims to make a system unavailable by overwhelming it with requests or data. A Distributed Denial of Service (DDoS) attack is a more sophisticated version, where the attack originates from multiple sources, making it harder to block. 

In the case of canisters, such attacks can quickly deplete cycles, making the canister unable to process legitimate requests. Learn more about DoS in the [Security Best Practices: Denial of Service](https://internetcomputer.org/docs/current/developer-docs/security/security-best-practices/dos) guide.

### Recommendation

To protect your canisters from DoS and DDoS attacks, consider the following strategies:
* **Bot prevention techniques**: Use methods like captchas or proof of work to ensure only legitimate users can access your canister. Captchas help verify that the user is human, while proof of work requires the user to spend computational resources to proceed, deterring automated attacks. An example implementation can be found in the [Internet Identity project](https://github.com/dfinity/internet-identity).
* **Monitor cycles usage**: Regularly track your canisters cycles consumption and set alerts for any sudden spikes that may indicate an attack.
* **Ingress message charging**: While charging for ingress messages (external requests to the canister) is not natively supported, custom solutions could be implemented to make sure that any expensive actions have costs associated with them.

## Protect Against Noisy Neighbors

### Security Concern

In a shared resource environment like the Internet Computer, multiple canisters can run on the same subnet. If one canister consumes too many resources (CPU, memory, etc.), it can negatively impact the performance of others on the same subnet. This is known as the "noisy neighbor" problem.

### Recommendation

To mitigate the "noisy neighbor" issue, manage your canister's resource allocation effectively:
* **Memory allocation**: You can set a memory reservation for your canister through the `memory_allocation` setting, ensuring that your canister has enough reserved memory to operate even if other canisters consume large amounts of resources.
* **Compute reservation**: Similar to memory, you can also reserve compute power for your canister, ensuring it has enough processing power to handle requests. Learn more about managing memory and compute resources in our [Storage](https://internetcomputer.org/docs/current/developer-docs/gas-cost#storage) and [Compute](https://internetcomputer.org/docs/current/developer-docs/gas-cost#compute) guides.
* **Subnet and canister distribution**: Implement a smart canister deployment strategy by monitoring the load on subnets. You can choose to deploy new canisters on less busy subnets or adopt a multi-canister architecture that balances the load across subnets. Be mindful to minimize inter-subnet communication for canisters that frequently interact with each other. Additionally, avoid deploying to known high-traffic subnets where possible, though keep in mind that resource usage can change unexpectedly with new dapps.


## Handle Expensive Calls

### Security Concern

Some calls (update or query) might be expensive in terms of the memory or cycles they consume, making it easy for malicious users to render your canister unusable by draining resources.

### Recommendation

* **Use captchas or proof of work**: If your application provides expensive operations (such as complex computations or large data storage), consider requiring users to complete a captcha or proof of work before proceeding. This can help prevent bots from abusing your system.
* **Charge for expensive calls**: You can require that certain expensive calls from other canisters include cycles to compensate for the resources consumed. One can charge for ingress messages as well. However, that is not currently supported by the protocol itself and a custom solution, such as pre-paying a certain amount, would need to be designed.
* **Differentiate between update and query calls**: Expensive computations should generally be avoided for update calls unless absolutely necessary. While query calls are not authenticated, they are faster and less resource-intensive. To check whether a method was called as a query or update, you can use `ic0.in_replicated_execution()`.

### Further Recommendations

- Monitor cycles consumption regularly.
- Implement early authentication and rate limiting for your canisters.
- Be aware of attacks targeting high cycles-consuming calls.
