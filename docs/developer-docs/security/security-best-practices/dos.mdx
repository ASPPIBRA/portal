---
keywords: [security, concept, denial of service, dos, cycles, captcha]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Security Best Practices: Denial of Service

<MarkdownChipRow labels={["Intermediate", "Security", "Concept"]} />


## Protect Against DoS and DDoS Attacks

### Security Concern

A Denial of Service (DoS) attack aims to make a system unavailable by overwhelming it with requests or data. A Distributed Denial of Service (DDoS) attack is a more sophisticated version, where the attack originates from multiple sources, making it harder to block. An attacker will typically search for operations that are free to be executed by anyone but which are expensive for the application in terms of certain resources such as storage, memory usage, network bandwidth, computing resources, etc. In the case of canisters, such attacks can aim to deplete cycles, making the canister unable to process legitimate requests. The reverse gas model means that a dapp needs to implement strategies to deal with this.

### Recommendation

To protect your canisters from DoS and DDoS attacks, consider the following strategies:
* **Bot prevention techniques**: Use methods like captchas or proof of work to ensure only legitimate users can access your canister. Captchas help verify that the user is human, while proof of work requires the user to spend computational resources to proceed, deterring automated attacks. An example implementation can be found in the [Internet Identity project](https://github.com/dfinity/internet-identity).
* **Monitor cycles usage**: Regularly track your canisters cycles consumption and set alerts for any sudden spikes that may indicate an attack.
* **Ingress message charging**: While charging for ingress messages (external requests to the canister) is not natively supported, custom solutions could be implemented to make sure that any expensive actions have costs associated with them.

## Protect Against Noisy Neighbors

### Security Concern

In a shared resource environment like the Internet Computer, multiple canisters can run on the same subnet. If one canister consumes too many resources (CPU, memory, etc.), it can negatively impact the performance of others on the same subnet. This is known as the "noisy neighbor" problem.

### Recommendation

To mitigate the "noisy neighbor" issue, manage your canister's resource allocation effectively:
* **Memory allocation**: Memory can be reserved per canister by setting `memory_allocation`. This ensures that your canister can always allocate memory up to the requested `memory_allocation`. Thereby preventing other canisters from using up the subnets available memory. Note that this also reduces the upper bound of memory the canister can allocate to the same value. Monitoring actual memory usage against this value is important to avoid availability issues.
* **Compute reservation**: Similar to memory, computing power can also be reserved by setting `compute_allocation` to a value between 0 and 100 which denotes the percentage of one CPU core to be reserved for this canister. A value of 50 means that every 2 rounds, the canister will be scheduled to execute a message. This guarantees a minimal progress you canister can make which protects against noisy neighbours. Both allocations are reserving resources for your canister on the subnet which prevents the other canisters from using them. Hence, they come at a cost. Memory allocation is charged as if all that memory would be allocated. Compute allocation is currently charged at 10M cycles per percentage point.
Learn more about managing memory and compute resources in our [Storage](https://internetcomputer.org/docs/current/developer-docs/gas-cost#storage) and [Compute](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution) guides.
* **Subnet and canister distribution**: Implement a smart canister deployment strategy by monitoring the load on subnets. You can choose to deploy new canisters on less busy subnets or adopt a multi-canister architecture that balances the load across subnets. Be mindful to minimize inter-subnet communication for canisters that frequently interact with each other. Additionally, avoid deploying to known high-traffic subnets where possible, though keep in mind that resource usage can change unexpectedly with new dapps.

## Handle Expensive Calls

### Security Concern

Some calls (update or query) might be expensive in terms of the memory or cycles they consume, making it easy for malicious users to render your canister unusable by draining resources.

### Recommendation

* **Use captchas or proof of work**: If your application provides expensive operations (such as complex computations or large data storage), consider requiring users to complete a captcha or proof of work before proceeding. This can help prevent bots from abusing your system.
* **Charge for expensive calls**: You can require that certain expensive calls from other canisters include cycles to compensate for the resources consumed. One can charge for ingress messages as well. However, that is not currently supported by the protocol itself and a custom solution, such as pre-paying a certain amount, would need to be designed.
* **Differentiate between update and query calls**: Expensive computations should generally be avoided for update calls unless absolutely necessary. While query calls are not authenticated, they are faster and less resource-intensive. To check whether a method was called as a query or update call, you can use `ic0.in_replicated_execution()`.

### Further Recommendations

- Monitor cycles consumption regularly.
- Implement early authentication and rate limiting for your canisters.
- Be aware of attacks targeting high cycles-consuming calls.
