---
keywords: [advanced, bitcoin, tutorial, btc, runes, schnorr, taproot]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Runes

<MarkdownChipRow labels={["Advanced", "Bitcoin", "Tutorial"]} />

## Overview

Bitcoin Runes are a type of fungible asset deployed on the Bitcoin network. Runes are not reliant on the [Ordinals protocol](ordinals.mdx) like other Bitcoin asset standards such as BRC-20 and SRC-20. Runes are designed to be an efficient and simple asset that utilizes Bitcoin's UTXO model and the `OP_RETURN` opcode.

The UTXO transaction model enables each transaction's output to hold information and be treated as digital currency. To initiate a transaction, you must use those outputs as your transaction's input. For Runes specifically, each UTXO can hold a different amount or type of Rune, simplifying the management of tokens on Bitcoin.

The Bitcoin opcode `OP_RETURN` enables additional information to be attached to a Bitcoin transaction, up to 80 bytes of data. Runes use this `OP_RETURN` value to store the token's data, such as name, symbol, commands, or ID. This token data is referred to as the 'Runestone'.

Creating a Rune is done through a process called 'etching', which refers to submitting a transaction to the Bitcoin network that specifies the Rune's data in the `OP_RETURN` output of a transaction. Once a Rune has been etched, it can be minted through open or closed mints. Open minting allows anyone to mint an instance of the Rune through a mint transaction, while closed minting refers to a set of requirements that must be met in order for the Rune to be minted. When a Rune is initially etched, the creator can set aside a portion of the Runes for themselves before others are minted.

## Runes on ICP

Canisters deployed on ICP can sign and submit transactions directly to the Bitcoin network through ICP's [Bitcoin integration](../overview.mdx) and [threshold signatures](/docs/current/references/t-sigs-how-it-works). Specifically, for a canister to etch and mint Runes, it must sign transactions using [threshold Schnorr signatures](/docs/current/references/t-sigs-how-it-works#deuterium-schnorr-release-beta) and have a [Bitcoin taproot address](/docs/current/developer-docs/multi-chain/bitcoin/using-btc/generate-addresses#generating-addresses-with-threshold-schnorr).

## Etching and minting Runes

To etch a Rune through a canister on ICP, first you will need to call the `schnorr_public_key` API to obtain a Schnorr public key. This public key will be used to generate a Bitcoin taproot (P2TR) address for your canister. A taproot address is required to sign and submit Rune transactions, both etching and minting, on Bitcoin. [Learn more about Bitcoin taproot addresses](/docs/current/developer-docs/multi-chain/bitcoin/using-btc/generate-addresses#generating-addresses-with-threshold-schnorr).

Once you have generated a taproot address for your canister, you will need to write a canister method that creates an etching transaction, then signs that transaction with your canister's Schnorr public key. Here's an example of an etching transaction written in Rust:

```rust
fn set_beginning_block() {
  let hash = BlockHash::from_str(FIRST_BLOCK_HASH).expect("valid hash");
  crate::increase_height(FIRST_HEIGHT, hash);
}

pub(crate) fn init_rune() {
  set_beginning_block();
  let rune = Rune(2055900680524219742);

  let id = RuneId { block: 1, tx: 0 };
  let etching = Txid::all_zeros();

  rune_to_rune_id(|r| r.insert(rune.store(), id)).expect("MemoryOverflow");

  rune_id_to_rune_entry(|r| {
    r.insert(
      id,
      RuneEntry {
        block: id.block,
        burned: 0,
        divisibility: 0,
        etching,
        terms: Some(Terms {
          amount: Some(1),
          cap: Some(u128::MAX),
          height: (
            Some((SUBSIDY_HALVING_INTERVAL * 4).into()),
            Some((SUBSIDY_HALVING_INTERVAL * 5).into()),
          ),
          offset: (None, None),
        }),
        mints: 0,
        premine: 0,
        spaced_rune: SpacedRune { rune, spacers: 128 },
        symbol: Some('\u{29C9}'),
        timestamp: 0,
        turbo: true,
      },
    )
  })
  .expect("MemoryOverflow");

  transaction_id_to_rune(|t| t.insert(Txid::store(etching), rune.store())).expect("MemoryOverflow");
}
```

<a href="https://github.com/octopus-network/ord-canister/blob/a0632ebd1493d604ad3e82185f75170755552ac3/src/index.rs#L19-L62">
    <div align="center">View the full example.</div>
</a>


## Querying Rune information

To query information about a Rune, you can specify a query call that returns the Rune information for a given UTXO. Here is an example using the Rust [Ordinals crate](https://crates.io/crates/ordinals/0.0.1):

:::info
The Rust Ordinals crate is not created or maintained by DFINITY. The ICP management canister does not currently provide endpoints to query Ordinal data.
:::

```rust
#[query]
pub fn get_runes_by_utxo(txid: String, vout: u32) -> Result<Vec<RuneBalance>, OrdError> {
  let k = OutPoint::store(OutPoint {
    txid: Txid::from_str(&txid).map_err(|e| OrdError::Params(e.to_string()))?,
    vout,
  });
  let v =
    crate::outpoint_to_rune_balances(|b| b.get(&k).map(|v| v.deref().iter().map(|i| *i).collect()))
      .unwrap_or_default();
  Ok(v)
}
```

<a href="https://github.com/octopus-network/ord-canister/blob/a0632ebd1493d604ad3e82185f75170755552ac3/src/canister.rs#L8">
    <div align="center">View the full example.</div>
</a>


## Resources

- [Runes example canister](https://github.com/octopus-network/ord-canister/tree/master)
