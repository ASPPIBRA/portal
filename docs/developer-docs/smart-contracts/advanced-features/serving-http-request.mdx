---
keywords: [advanced, tutorial, serving http, http requests]
---

import TabItem from "@theme/TabItem";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Serving an HTTP request

<MarkdownChipRow labels={["Advanced", "Tutorial"]} />

## Overview

Canisters can serve or handle an incoming HTTP request using the [HTTP Gateway Protocol](/docs/current/references/http-gateway-protocol-spec).

This allows developers to host web applications and APIs from a canister.

## How it works

An HTTP request from a client gets intercepted by the HTTP Gateway Protocol, which identifies the target canister and encodes the request in Candid. This encoded request is then sent to the canister for processing. Once processed, the canister replies with an HTTP response. Finally, the HTTP Gateway Protocol decodes the response using Candid and sends it back to the client, completing the communication loop.

For detailed information on how it works, please refer to the [HTTP Gateway Protocol specification](/docs/current/references/http-gateway-protocol-spec).

## How to make a request

The following example returns 'Hello, World!' in the body at the `/hello` endpoint.

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko">

```motoko
import Buffer "mo:base/Buffer";

type HeaderField = (Text, Text);

type HttpResponse = {
    status_code: Nat16;
    headers: [HeaderField];
    body: Blob;
};

type HttpRequest = {
    method: Text;
    url: Text;
    headers: [HeaderField];
    body: Blob;
  };

public query func http_request(req: HttpRequest): async (HttpResponse) {
    let path = removeQuery(req.url);
    if(path == "/hello") {
        return {
            status_code = 200,
            headers = [],
            body = Buffer.from('Hello, World!'),
        };
    };
        return {
            body = Text.encodeUtf8("404 Not found :");
            headers = [];
            status_code = 404;
    };
};
```

</TabItem>

<TabItem value="rust" label="Rust">

```rust
type HeaderField = (String, String);

struct HttpResponse {
    status_code: u16,
    headers: Vec<HeaderField>,
    body: Cow<'static, Bytes>,
}

struct HttpRequest {
    method: String,
    url: String,
    headers: Vec<(String, String)>,
    body: ByteBuf,
}

#[query]
fn http_request(req: HttpRequest) -> HttpResponse {
    let path = req.url.path();
    if path == "/hello" {
        HttpResponse {
            status_code: 200,
            headers: Vec::new(),
            body: b"hello, world!".to_vec(),
            streaming_strategy: None,
            upgrade: None,
        }
    } else {
        HttpResponse {
            status_code: 404,
            headers: Vec::new(),
            body: b"404 Not found :".to_vec(),
            streaming_strategy: None,
            upgrade: None,
        }
    }
}
```

</TabItem>

<AdornedTab value={"typescript"} label="TypeScript" endAdornment={<BetaChip />}>

To serve HTTP requests, you can use the Azle `http-server` functionality by creating a new project with the flag `--http-server`:

```
npx azle new http_requests --http-server
cd http_requests
```

Then, use the `fetch` functionality to create an HTTP server that can process incoming requests:


```typescript
import { ic, query, Server } from 'azle/experimental';
import {
    HttpResponse,
    HttpTransformArgs
} from 'azle/experimental/canisters/management';
import express from 'express';

export default Server(
    () => {
        const app = express();

        app.use(express.json());

        app.get('/fetch-head', async (_req, res) => {
            const response = await fetch(
                `https://cat-fact.herokuapp.com/facts/591f989cd369931519ce361d`,
                {
                    method: 'HEAD'
                }
            );

            res.json(Array.from(response.headers.entries()));
        });

        app.get('/fetch-get', async (_req, res) => {
            const response = await fetch(
                `https://cat-fact.herokuapp.com/facts/591f989cd369931519ce361d`
            );

            res.json({
                headers: Array.from(response.headers.entries()),
                body: await response.json()
            });
        });

        app.get('/fetch-get-query-params', async (_req, res) => {
            const response = await fetch(
                `https://cat-fact.herokuapp.com/facts/random?amount=2`
            );

            res.json(await response.json());
        });

        app.post('/fetch-post', async (_req, res) => {
            const response = await fetch(new URL('https://rpc.ankr.com/eth'), {
                method: 'POST',
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'eth_getBalance',
                    params: [
                        '0xeac0827eff0c6e3ff28a7d4a54f65cb7689d7b99',
                        'earliest'
                    ],
                    id: 1
                })
            });
            const responseJson = await response.json();

            res.json(responseJson);
        });

        app.get('/request-headers', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/headers`, {
                headers: {
                    'X-Azle-Request-Key-0': 'X-Azle-Request-Value-0',
                    'X-Azle-Request-Key-1': 'X-Azle-Request-Value-1',
                    'X-Azle-Request-Key-2': 'X-Azle-Request-Value-2'
                }
            });
            const responseJson = await response.json();

            res.json(responseJson);
        });

        app.get('/get-status-201', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/201`);

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.post('/get-status-205', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/205`, {
                method: 'POST'
            });

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.get('/get-status-301', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/301`);

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.post('/get-status-304', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/304`, {
                method: 'POST'
            });

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.get('/get-status-401', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/401`);

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.post('/get-status-418', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/418`, {
                method: 'POST'
            });

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.get('/get-status-500', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/500`);

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.post('/get-status-501', async (_req, res) => {
            const response = await fetch(`https://httpbin.org/status/501`, {
                method: 'POST'
            });

            res.json({
                status: response.status,
                statusText: response.statusText
            });
        });

        app.get('/transform', async (_req, res) => {
            ic.setOutgoingHttpOptions({
                transformMethodName: 'transform'
            });

            const response = await fetch(`https://httpbin.org/headers`, {
                headers: {
                    'X-Azle-Request-Key-0': 'X-Azle-Request-Value-0',
                    'X-Azle-Request-Key-1': 'X-Azle-Request-Value-1',
                    'X-Azle-Request-Key-2': 'X-Azle-Request-Value-2'
                }
            });

            res.json(Array.from(response.headers.entries()));
        });

        app.get('/transform-with-context', async (_req, res) => {
            ic.setOutgoingHttpOptions({
                transformMethodName: 'transform',
                transformContext: Uint8Array.from([0, 1, 2])
            });

            const response = await fetch(`https://httpbin.org/headers`, {
                headers: {
                    'X-Azle-Request-Key-0': 'X-Azle-Request-Value-0',
                    'X-Azle-Request-Key-1': 'X-Azle-Request-Value-1',
                    'X-Azle-Request-Key-2': 'X-Azle-Request-Value-2'
                }
            });

            res.json({
                headers: Array.from(response.headers.entries()),
                body: (await response.arrayBuffer()).byteLength
            });
        });

        app.get('/max-response-bytes', async (_req, res) => {
            try {
                ic.setOutgoingHttpOptions({
                    maxResponseBytes: 0n
                });

                const response = await fetch(
                    `https://httpbin.org/get?hello=world`
                );

                res.json({
                    headers: Array.from(response.headers.entries()),
                    body: (await response.arrayBuffer()).byteLength
                });
            } catch (error) {
                res.json(error);
            }
        });

        app.get('/cycles', async (_req, res) => {
            try {
                ic.setOutgoingHttpOptions({
                    cycles: 0n
                });

                const response = await fetch(
                    `https://httpbin.org/get?hello=world`
                );

                res.json({
                    headers: Array.from(response.headers.entries()),
                    body: (await response.arrayBuffer()).byteLength
                });
            } catch (error) {
                res.json(error);
            }
        });

        return app.listen();
    },
    {
        transform: query(
            [HttpTransformArgs],
            HttpResponse,
            (httpTransformArgs) => {
                return {
                    ...httpTransformArgs.response,
                    headers: [],
                    body: httpTransformArgs.context
                };
            }
        )
    }
);
```

To learn more about serving an HTTP request in Typescript, refer to [the Azle book reference on fetch](https://demergent-labs.github.io/azle/fetch.html).

</AdornedTab>

<AdornedTab value={"python"} label="Python" endAdornment={<BetaChip />}>

```python
from kybra import blob, Func, nat16, Opt, query, Query, Record, Tuple, Variant, Vec


class HttpRequest(Record):
    method: str
    url: str
    headers: Vec["Header"]
    body: blob

class HttpResponse(Record):
    status_code: nat16
    headers: Vec["Header"]
    body: blob

Header = Tuple[str, str]

@query
def http_request(req: HttpRequest) -> HttpResponse:
    path = req.url.path
    if path == "/hello":
        return {
            "status_code": 200,
            "headers": [],
            "body": Buffer.from_text("hello, world!").encode("utf-8"),
        }
    else:
        return {
            "status_code": 404,
            "headers": [],
            "body": b"404 Not found :",
}
```
To learn more about serving an HTTP request in Python, refer to [the Kybra book reference on incoming HTTP requests](https://demergent-labs.github.io/kybra/http.html).

</AdornedTab>
</AdornedTabs>

## Additional examples

The [HTTP counter project](../../../references/samples/motoko/http_counter) is an example in Motoko of a 'counter' application that uses the `http_request` method to read the current counter value or access some pre-stored data and the `http_request_update` method to increment the counter and retrieve the updated value.
