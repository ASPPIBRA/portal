# Architecture 

## Overview 

One of the most important decisions when designing a dapp is the determining the project's architecture. Three commonly used project architectures include:

- **Single canister projects**: Contain a single canisters that contains the entire project's functionality. This may be a single service, a frontend webpage, or both within a single canister. Benefits of single canister projects include:

    - Simplified management and maintenance.

    - A lower cost than some multi-canister projects (though this depends on several factors). 

    - Can be a good starting place for new developers as they learn about developing on ICP. 

    Example use cases:

    - Hosting a webpage or website.

    - Hosting a simple service, such as a calculator.

    - Hosting a simple game.

    - Hosting a simple dapp with frontend and backend code together in a single canister. 

- **Multi-canister projects**: Contains multiple canisters that divide the project's functions into several canisters with specific purposes. Multi-canister projects are the default project architecture generated by the `dfx new` command. The most common multi-canister architecture consists of a canister for the project's frontend assets and a canister for the dapp's backend code. Multi-canister projects are also commonly used when it makes sense to place different reusable services into separate canisters. Benefits of multi-canister projects include:

    - Better scalability than single canister projects.
    
    - Upgrading individual services may be easier. 

    - Canisters providing a reusable service can be configured as ['pullable'](/docs/current/developer-docs/setup/best-practices/pulling-canister-dependencies) and re-used in other projects through [`dfx deps`](/docs/current/references/cli-reference/dfx/dfx-deps). 

    Example use cases:

    - A fullstack dapp with a frontend application and several backend functionality canisters.

    - A decentralized exchange or token swap dapp.

    - A social media dapp. 

    - A video streaming dapp.

    - A photo upload and storage dapp.

    - A decentralized game.

    - An NFT collection and a frontend application to mint, sell, or buy NFTs. 

- **Personal canister projects**: Uses automatic canister generation and deployment for each user that registers with the application. This architecture often also includes several specific-purpose canisters that provide the application's functionality, but each user has their own canister with their personal user data. In some applications, the user has ownership and control of their personal canisters, though in other instances they do not. Benefits of using a personal canister architecture include:

    - Highly scalable due to optimizations regarding usable memory, transactions per second, and total inter-canister calls. 

    - For applications where the user owns their canister, this architecture enables user empowerment and increased data ownership. 

    This approach can become costly quickly. If an application has an influx of user sign-ups, the developer is responsible for the gas cost of deploying hundreds or thousands of canisters. 

    Example use cases:

    - A chat dapp where the user owns their conversation history.

    - A social media dapp where the user owns their profile. 

    - A file storage dapp where the user owns their uploaded data. 

## Architectures compared 

| Feature | Single | Multi | Personal | 
|---------|--------|-------|----------|
| Management | Single canister to manage. | Multiple canisters to manage, but each canister has a specific function. | Complex, canister management needs to be automated with another canister.|
| Scalability | Hard to scale for large projects. | Better scalability than single projects. | Highly scalable and optimizable. |
| Reusability | Typically can't be reused. | Service-specific canisters can be reused in other projects. | User data canisters cannot be reused for different applications.|
| Cost | Typically relatively low, but will depend on total number of resources used. | Larger cost than single canister, but will vary drastically based on total number of canisters and resources used. | Traditionally the most expensive architecture, and costs increase in correlation with number of users on the application. |

## Architecture best practices

### Recommendation: Serve reusable services in their own canisters 

Serving individual services in their own canisters makes it easy to call, manage, and reuse those services. For example, a social media application may have functionality for creating user profiles, sending messages, or uploading photos. If these three services are separated into three separate canisters, managing, upgrading, and using those services is simplified. Additionally, these canisters can each be published as ['pullable'](/docs/current/developer-docs/setup/best-practices/pulling-canister-dependencies) canisters, then reused in another dapps, preventing developers from having to redeploy the same code in different projects.

### Recommendation: End-users should interact with a dapp from a frontend application

For the best user experience, end-users should interact with dapps from a frontend application. Using a frontend application provides users with a familiar interface to interact with dapps, while the alternative (calling the canister via the CLI or Candid) can be difficult for non-technical users and lead to a poor user experience. 

### Recommendation: For better data ownership, separate each user's data into their own canister

Developers that use the **personal canister** architecture can enable users to own their data by providing them ownership of their canister. If the user doesn't own their own canister, they do not have full ownership of their data. 

### Recommendation: Use multiple keys to further secure assets

For dapps that provide custodial functions, such as holding or trading assets, you can secure these assets further by utilizing multiple [TECDSA keys](/docs/current/developer-docs/integrations/t-ecdsa/index) hosted on different subnets. By using two keys, multiple subnets would have to conspire and collaborate to compromise assets.






